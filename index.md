---
layout: default
title: Benjamin Mills ePortfolio
---
# Welcome to My CS-499 ePortfolio
My name is Benjamin Mills, and this is my ePortfolio, which highlights my time and efforts at SNHU. This ePortfolio will take you through my personal journey in the Computer Science world from start to finish. You can expect to see 3 artifacts later on that highlight what I have learned and how I have improved throughout my time at SNHU.

## Introduction
I am a Computer Science Major at SNHU; however, that isn't where I started. Beginning in high school, I found myself interested in technology, with computers and programming being a major part of my life. My biggest deciding factor in pursuing further education with computers was my older brother. He was always participating in competitions that I would get to see. One that stuck out to me was a robotics competition where his team built a robot that could navigate an underwater maze. At the time, I decided to follow in his footsteps by pursuing the same degree as him in CS. This led me to start at a community college where I enrolled at AACC. I started in 2020, finishing in late 2022 with an Associate of Science in Computer Science. From there, I spent my time completing certifications and continuing my learning outside of an educational institution as financial setbacks prevented me from immediately starting on my Bachelors. Ultimately, I decided to continue my education where my oldest brother earned his degree from, SNHU, in 2024.

Coming into SNHU, I had foundational programming knowledge from AACC and developed IT concepts, earning my professional certifications. This led to me feeling confident in my coding abilities, and I believed I would excel with ease when I started at SNHU. That confidence was certainly put to the test throughout my time at SNHU. New concepts I was unfamiliar with would constantly be taught. What I thought I had practiced skill had further room for improvement. I felt myself being challenged in my courses as topics I knew well at a surface level were discussed at a more advanced level. This often made me question if I would do well once I leave the program. However, with the challenge came a need to prove myself, which continues to this day as I continue to improve and apply my knowledge in relevant ways.

My previous coursework found on my GitHub helps highlight my growth throughout my program. When looking at potential projects to enhance, I purposefully chose an older project for my artifacts to improve. My growth is better shown by improving my older projects, while a complementary recent project highlights my current skills. This ePortfolio showcases my skills acquired through my time at SNHU by drawing attention to 3 chosen artifacts. The artifacts shown in this ePortfolio draw attention to a limited portion of my talents, as they do not include my outside learnings, like my certifications or personal projects. Despite that, this ePortfolio will highlight my strengths in programming, specifically targeting concepts relating to Software Design and Engineering, Algorithms and Data Structures, and Databases.

One professional value that I have learned is collaboration. Despite the artifacts being created independently, my personal projects and the projects chosen for enhancement highlight the importance of collaboration. The project used for artifact 3 had the website visuals already designed and created. This made my job of implementation into a functional website quick and streamlined. Similarly, in my personal projects, I break up tasks with my group based on my colleagues' strengths. I ensure to incorporate their feedback and offer my input on their work. A good example can be found in one of my projects for visual entertainment. I had my colleague prototype my work to find errors or areas that had room for improvement that I overlooked. Throughout the capstone course, I gave detailed explanations of what was done and what will be done. This replicates how communicating project development is done in a professional setting. From the plan phase to the final reflection, the level of communication I performed is like real-world check-ins with stakeholders on project status.

I have learned and ingrained skills related to data structures and algorithms to create programs that are efficient and scalable. These skills allow me to know which data structure will best fit any given scenario. Deciding which to use requires understanding how different structures will impact a program's resource consumption. I have learned that creating efficient and scalable programs isn't always enough to achieve value. That is why I developed strong software engineering principles and soft skills to recognize the needs of the project. These software engineering skills create programs that not only reach the goal but do so in a structured and targeted way. Soft skills like empathy and user-focused questioning allow me to understand the problem deeper and create a solution that solves their problem rather than just fulfilling a set of requirements. Only focusing on a list of requirements may create vulnerabilities not originally accounted for. That is why throughout this program, my professional certifications, and my personal life, one fact has remained true, which is always a need for greater security. Secure concepts have been drilled into me in every aspect of my teaching, and now I create code that always has security at the forefront of the design.

This portfolio's focus is based on 3 artifacts that improve upon old projects completed in this program. The projects I selected are listed with the respective artifacts and have links to both the original and enhanced versions. The first artifact improves the functionality of an older project in my program, keeping in mind the original project's need for security automation. This enhancement focuses on the original project's goal and what is missing from the original project's design. In addition, the improvement will improve aspects of the project to reflect my current standards. The first artifact highlights my critical thinking and secure coding principles. This enhancement focuses on value creation and understanding project goals. The second artifact focuses on resource efficiency and effective communication by increasing the speed of the program through data structure reconfiguration and coding adjustments. The second enhancement achieves this by reimplementing existing code to a new structure and effectively conveying complex algorithmic topics in ways anyone can understand. The third artifact is implemented on one of my most recent projects and highlights my current technical skills. This enhancement will incorporate soft skills like critical thinking and technical skills related to web development. Before enhancements were made on the projects, I first analyzed the pre-existing projects to understand their current state. During that analysis, known as a code review, I gave the specifics on the proposed enhancements in a short informal presentation.

## Code Review

<div class="video-container">
  <iframe width="640" height="390" 
    src="https://www.youtube.com/embed/GnDcM9CBogA" 
    title="Benjamin Mills CS-499 Code Review" frameborder="0" 
    allowfullscreen>
  </iframe>
</div>

<style>
.video-container {
  position: relative;
  padding-bottom: 56.25%;
  height: 0;
  overflow: hidden;
  max-width: 100%;
}

.video-container iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
</style>

Above, you will find a link to my code review that was recorded before the enhancements were implemented in the projects. If the above video does not work, you can also find my video [Here](https://www.youtube.com/watch?v=GnDcM9CBogA). A code review is a review of the code that involves ensuring that the code meets specified functional requirements, is error-free, is built to proper standards, is properly documented, and achieves style guidelines. It analyzes the code for existing unaddressed problems, areas of improvement, is a great tool for team collaboration, and offers a chance for self-reflection. This was an individual code review, in which I analyzed the existing projects and checked them against the guidelines set in the checklist. I also explained the proposed enhancements deeper, explaining where and how the enhancements fit into the existing project.

To summarize the existing code review, it starts by analyzing the CS-320 Project, which is used for the first and second artifact. The project is written in Java and inspected in the Eclipse IDE. The original project's goal was to be a part of a mobile application, with security and speed being top concerns. The project consists of 3 main parts being the Appointment, Contact, and Task portions. Each portion has 4 classes: a base object to house data, a controller class that stores an ArrayList of the base objects, and a test class for the base object and the controller. Each base class, such as the Appointment class, stores a unique ID and relevant data connected to that object. The controller class, like the AppointmentService class, handles operations such as adding a new Appointment or modifying existing objects. The test classes test the specific requirements of the original project, and each created function using JUnit. From the provided checklist, the project passes the structure portion for the most part, although a library function could have been used if the project is to remain in the ArrayList structure. The project has improvements in the documentation, with unnecessary documentation and an inconsistent commenting structure throughout. The project passes the arithmetic portion, although it doesn't apply to the existing code. The project generally passes the loops portion of the checklist, although there may be a better way to structure base cases. Finally, the project passes all the defense criteria in the checklist that apply to this specific project.

The first enhancement was made from the topic of Software Design and Engineering. The code review explains that the planned enhancement will expand on the missing R in CRUD operations from the project, which is the Read operation. The ability to retrieve stored data is crucial for this mobile application but was an overlooked part of the original project. The read operation will be incorporated into all 3 portions of the project, inside the controller classes. This enhancement highlights the design aspect, as it recognizes crucial functionality that was overlooked, which makes much of the mobile application completely unusable.

The second enhancement was made from the topic of Algorithms and Data Structures. This was also made in the CS-320 project. This enhancement will change the ArrayList structure in the controller classes into a binary search tree, or BST, structure instead. The code review explains that this will apply to all 3 portions of the project but will still return an ArrayList from the created read functionality in enhancement 1. The reason behind this decision is that the other portions of the mobile application will be making use of the read function and will likely be expecting an ArrayList. This will allow those functions to still work properly. The code review defends the choice of a BST by explaining its speed benefits, maintainability, and ease of integration with existing code.

The code review then looks at the other project being worked on from CS-465. It is a full-stack project that is a travel booking website. The website contains 2 key parts, which are the customer-facing part and the Single-page application (SPA) administrator part. The SPA allows for adding and editing trips once logged in and will be reflected in both the SPA and the main customer page of the website. The review then looks more in-depth at the specific parts of the code that will be worked on in the enhancement. These parts are the app_api controllers and router. This project is one of the most recent projects I completed, which is reflected in the documentation and techniques used. This is further shown by the code passing everything on the checklist, with a small note on leftover testing stubs left purposefully for website maintenance.

The code review then explains the third enhancement that will be done on the project from the topic of Databases. The website is missing the ability to delete trips or admin users without directly removing them from the MongoDB database. The enhancement plans on adding deletion capabilities to the website for both trips and users. This enhancement is defended by explaining how trips may no longer be available so without being able to delete them, may confuse customers. Similarly, the code review explains security vulnerabilities from leaving admin accounts open without the ability to delete them when the employee is no longer a part of the company or their account is compromised.

The conclusion of the code review quickly goes back to the projects and the enhancements that will be made. It mentions where the enhancements can be found in this ePortfolio.

## Artifact One - Software Design and Engineering
The Original Project can be found -> [Here](https://github.com/Ben625e/CS-320)

The Enhanced Project can be found -> [Here](https://github.com/Ben625e/Ben625e.github.io/tree/main/BenjaminMillsCS320ProjectOneEnhancement1)

The following images provide quick recap of what was shown in the code review:<br><br>

![Project View](/docs/assets/images/CS320ProjectView.png)

This shows the original projects files, note that each of the 3 portions of the project (AppointmentService, ContactService, and TaskService) each have 2 functional class files and 2 testing class files.<br><br><br>

![Object View](/docs/assets/images/CS320ObjectView.png)

This shows one of the base classes, the Appointment class. Note on line 12 the unique ID, this is shared between all the base classes. You can also see that certain restrictions are placed on each stored data like on line 15, where it says that descriptions should not be empty and should be less than 51 characters.<br><br><br>

![Service View](/docs/assets/images/CS320ServiceView.png)

This shows one of the controller classes, the AppointmentService class. Note that the original implementation used an ArrayList structure, also known as a vector in other languages.<br><br><br>

![Test View](/docs/assets/images/CS320TestView.png)

This shows one of the testing classes, the AppointmentServiceTest class. The testing classes make use of JUnit for executing the test scripts.<br>

This artifact expands on a security project done in my CS program by adding read functionality to the locally stored data and adding JUnit test functions to accompany the newly created functions. The artifact uses an insertion method for gathering and sorting the data into an ArrayList, or more commonly known as a vector. The JUnit test is a positive test that inserts data and checks that the data is properly sorted when the read function is called.<br><br>

![Read View](/docs/assets/images/CS320ReadEnhance1.png)
![Test View](/docs/assets/images/CS320ReadTestEnhance1.png)

The above images show the implementation of the read function and accompanying test function in the Appointment portion of the project. This was also implemented for the Contact and Task portions of the project.<br>

This project and the artifact were chosen due to their expansion on security concepts that how grown during my program. In my personal projects, I often create programs that use my creative and design skills. These programs are created with the purpose of entertainment, which requires strong design principles paired with practical development skills. So, when I was choosing potential artifact projects, I wanted to choose something that I could apply what I have practiced while also highlighting skills I don’t often showcase in my work. This artifact highlights my ability to efficiently and effectively create software that solves a design flaw with a program. In this case, the lack of being able to retrieve the stored data is detrimental to this mobile application. It also highlights my growth, as this class was taken much earlier in my program. This enhancement created a more complete program by fixing a design flaw, creating cleaner code, and improving the built security system.

When working on this project, I was able to look at my old standards and directly compare them with my new standards. One thing I found interesting was how I used to over-label the code, such as adding comments to code comparisons that are obvious. Back then, I remember my mindset being that the more comments, the better, since it would make it easier to find out what everything does. It might be that I am just more experienced with coding now, but I now find all those comments distracting. I updated the comment structure to give more generalized descriptions and only labeled parts that are not immediately understood. This creates a cleaner-looking code and makes it easier to maintain in future updates. I don’t think that either method is wrong; however, it was interesting to see how I have grown in small ways. The commenting structure is a single example of that. Below you will see the previous object image and the restructured version after the enhancement was completed. 

![Object View](/docs/assets/images/CS320ObjectView.png)
![Comment View](/docs/assets/images/CS320CommentEnhance1.png)

One roadblock I had when creating the code that I didn’t recognize in the proposal was the language this project was written in. Python is my main language, but the project was written in Java. Although the logic was correct in the proposal, I failed to recognize that Java does not automatically know how to compare with comparator signs, such as <, with certain data types, such as strings. That caused a small hiccup since I needed to compare the data types for the function. However, I quickly read through the documentation and found the needed comparison methods. After reading how the comparison methods worked, I was able to adjust my logic and achieve the same result. Another snag I had was when I tried to come up with a negative test for the read function. I wanted to create a positive and negative test that would cause the catch to execute. However, I tried several negative tests, and they all failed because they would stop earlier on. As an example, I tried putting in a null value, but the way the Appointment class is set up, a null value is immediately recognized, and an exception is thrown. Due to many negative tests getting caught, I found no need for a negative test in this case. Ultimately, I decided that the positive test was sufficient. The biggest takeaway from this enhancement is how much I have grown compared with when I completed this project. My speed at creating and overcoming roadblocks is much faster than back then. I remember needing to look up different documentation to implement logic. This time, I felt I had memorized it all, and it came naturally when scripting.

## Artifact Two - Algorithms and Data Structures
The Original Project can be found -> [Here](https://github.com/Ben625e/CS-320)

The Enhanced Project can be found -> [Here](https://github.com/Ben625e/Ben625e.github.io/tree/main/BenjaminMillsCS320ProjectOne)

This artifact improves the efficiency of the controllers by moving from an ArrayList structure to a BST structure. The entire code had to be reformatted to incorporate the new structure, and the security automation JUnit scripts had to be reworked with some new tests being added. This work was done on all 3 portions of the project, which include the Appointment, Contact, and Task portions of the project. This ultimately created 6 new scripts for the project.<br><br>

![Node View](/docs/assets/images/CS320NodeEnhance2.png)
![BST View](/docs/assets/images/CS320BSTEnhance2.png)
![Test 2 View](/docs/assets/images/CS320TestBSTEnhance2.png)
![Read 2 View](/docs/assets/images/CS320ReadEnhance2.png)

The above images show the implementation of the BST. The node structure is a newly created class that is used for the BST implementation. The BST achieves all the previous controller classes' functionality. Similarly, the test class achieves all the previous test functions and includes newly added ones to better test the BST.<br>

This artifact was partially chosen due to its improvement on the project from enhancement one, allowing for the project to be brought even more up to my current coding standards. While my first improvement did improve on the project in designed focus ways, the project, being older, still had algorithmic flaws that could be fixed. It better showcases my improvement during my time in the program, as I get to showcase more advanced techniques by applying them to a single project across two separate enhancements. This enhancement shows my ability to improve program speed through algorithmic calculations, repurpose code to an entirely different data structure, and how to effectively present those improvements. The artifact can now handle much larger amounts of data much more efficiently and will be more scalable in the future. While not a part of my original proposal, I added three speed testing scripts to the original AppointmentService test script and the new AppointmentBSTService test script to highlight the speed difference. The results are very telling, with the old system taking around 30 seconds to get through the speed tests while the new system takes less than a quarter of a second. The created test scripts and results can be seen below.

![BST Speed View](/docs/assets/images/CS320BSTSpeedEnhance2.png)
![Speed View](/docs/assets/images/CS320SpeedEnhance2.png)
![BST Speed Result View](/docs/assets/images/CS320BSTSpeedResultEnhance2.png)
![Speed Result View](/docs/assets/images/CS320SpeedResultEnhance2.png)

Working on this enhancement further demonstrated to me how understanding a data structure is only half the battle when implementing it. In my original plan, I had planned for the Node and BST structure to be under one script. However, Java does not easily accommodate that, so I had to split them up across two scripts. This wasn’t a big roadblock, but just one of the many instances where language differences caused hiccups in my implementation. Another example that tripped me up was how Java treated the variables. It was stored by reference by default, meaning I didn’t need to explicitly define it as a reference variable, which caused further divergence from how I originally planned to implement the BST. Smaller differences that occurred had me looking into libraries and coding documentation, such as directly comparing Strings could not be done with symbols like > or <, but required functions like compareTo() to achieve. I will say that after this enhancement and writing over 1000+ lines of code to implement it, I am much more familiar with Java and its respective libraries. One thing I also noticed while reworking the JUnit tests was the need for variables that were considered good, with working data. I ended up putting these at the top before tests occurred helping if parameters change in the future. Instead of having to change the variable in each individual test, you will now only have to change the variable at the top, and it will be changed across the whole testing script. Small maintenance improvements like that occurred while working on this enhancement which highlight how I can now recognize coding problems before they occur.

## Artifact Three - Databases
The Original Project can be found -> [Here](https://github.com/Ben625e/CS465-fullstack) (Note: You will have to go to the module8 branch which can also be found [Here](https://github.com/Ben625e/CS465-fullstack/tree/module8))

The Enhanced Project can be found -> [Here](https://github.com/Ben625e/Ben625e.github.io/tree/Enhancement)

The artifact was to create delete functionality for the travel booking website that was created using Angular, MongoDB, and Express. The created functions had to be routed to the database and successfully make changes, which should be shown on the website, and the results should send back the deleted data.<br><br>

![New User View](/docs/assets/images/CS465NewUserEnhance3.png)<br>
This image shows the created account I made on the SPA portion of the website, in the database.<br><br><br>
![New Trip View](/docs/assets/images/CS465NewTripEnhance3.png)<br>
This image shows a newly created trip on the bottom right named “Test’s Trip” on the SPA.<br><br><br>
![New Trip Data View](/docs/assets/images/CS465NewTripDataEnhance3.png)<br>
This shows the test trip’s information in the database.<br><br><br>
![New Trip Delete View](/docs/assets/images/CS465DeleteTripEnhance3.png)<br>
This screenshot shows a successful delete request, using the unique trip code in the parameters.<br><br><br>
![New Trip Gone View](/docs/assets/images/CS465TripGoneEnhance3.png)<br>
This shows the trip gone from both the database and on the website.<br><br><br>
![New User Delete View](/docs/assets/images/CS465DeleteUserEnhance3.png)<br>
This shows a successful delete user function, which requires data to be sent along with the request, shown in the email under “Body”.<br><br><br>
![New User Gone View](/docs/assets/images/CS465UserGoneEnhance3.png)<br>
This is the database showing only a single admin user after the delete function was performed.<br>

This project was the most recent project that I completed in my program. It was a class taken at the end of my program and was taken right before the capstone course. I wanted to have an old project to showcase how I can improve older and lower-quality designs, but I also wanted a newer project to highlight my growth through the program and current skillset. I think that this project accomplishes that greatly, as it shows my improvements in coding style, what skills I have, and overall critical thinking in terms of this project's scenario. The artifact itself highlights my skills in web development, from front-end to back-end, and working with databases. The artifact improves the functionality of the website by completing CRUD capabilities. The website was missing the ability to delete from the database, which is now possible due to this artifact's inclusion.

Creating this artifact had a stressful planning process. I found myself worrying about the planned changes, as this project was my most recent and my least familiar. Web development done in this project was my first- and only-time making use of some of the tools and techniques like Postman, web tokenization, and Visual Studio Code. Due to this, I came into this enhancement by heavily planning how the implementation should look and heavily testing every aspect. Shockingly, this was the enhancement I had the least hiccups on, having no problems from implementation to testing. I think this showcases that it is easy to underestimate what you know in terms of coding and miss out on small things that you’re familiar with. The 2nd artifact was what I was most familiar with, but I had to look through the most documentation, while with this enhancement, I was able to find all the relevant libraries without much outside research. The biggest challenge with this artifact was planning, as I wanted to ensure that I didn’t break the website in a way I wouldn’t understand. However, once I started, I found it to be quite a smooth process. My anxiety towards starting this enhancement ended up being overblown, and I am now much more confident in my skills in web development from this.

## Conclusion
